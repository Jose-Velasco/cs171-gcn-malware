import os.path as osp
from os import walk
from pathlib import Path
import glob
import torch
from torch_geometric.data import Dataset, Data
from gensim.models import KeyedVectors
import numpy as np
from utils import save_dict_if_changed, generateFamilyLabels

class APICallGraphDataset(Dataset):
    def __init__(self, root: str, processSubDir: str, fileNameMetaInfoSuffix: str, apiCallEmbeddingsFilePath: str, weighted: bool, allClassLabels: dict[str, int], transform=None, pre_transform=None, pre_filter=None):
        self.apiCallEmbeddingsFilePath: str = apiCallEmbeddingsFilePath
        self.apiToNodeIndex: dict[str, int] = {}
        self.nodeIndexToApi: list[str] = []
        self.weighted = weighted
        self.nodeFeatures: torch.Tensor | None = None
        self.allClassLabels: dict[str, int] = allClassLabels
        self.processSubDir = processSubDir
        # self.fileNameMetaInfoSuffix = "UD_W"
        self.fileNameMetaInfoSuffix = fileNameMetaInfoSuffix
        super().__init__(root, transform, pre_transform, pre_filter)

    @property
    def processed_dir(self) -> str:
        return osp.join(self.root, 'processed', self.processSubDir)
   
    @property
    def raw_file_names(self):
        # rootDir: str = super().root
        rootDir: str = self.root
        filePaths: list[str] = []
        for subdir, dirs, files in walk(osp.join(rootDir, "raw")):
            for file in files:
                filePath: str = osp.join(subdir, file)
                filePaths.append(filePath)
                # filePaths.append(file)
        return filePaths

    @property
    def processed_file_names(self):
        rawFilePaths: list[str] = self.raw_file_names
        processedFileNames: list[str] = []
        for idx, filePath in enumerate(rawFilePaths):
            filePathObj = Path(filePath)
            # fileName = filePathObj.stem
            # parentDirPath = filePathObj.parent
            # parentDirName = parentDirPath.stem
            # procFileName = f"{parentDirName}_{fileName}_{idx}.pt"
            procFileName = self._make_file_name(filePathObj, self.fileNameMetaInfoSuffix, idx)
            processedFileNames.append(procFileName)
        return processedFileNames

    def download(self):
        # Download to `self.raw_dir`.
        pass

    def process(self):
        self.nodeFeatures = self._load_node_feature()
        for idx, raw_path in enumerate(self.raw_file_names):
            filePathObj: Path = Path(raw_path)
            # Undirected weighted
            outputGraphFileName = self._make_file_name(filePathObj, self.fileNameMetaInfoSuffix, idx)
            # processedFilePath = f"{outputGraphFileName}"
            allEdges, allEdgeFeatures, nodes, nodeNames = self._construct_graph(raw_path)
            
            numericalFamilyValue = self.allClassLabels[self._get_label(filePathObj)]
            # graphLabel = self.one_hot_encode(self._get_label(filePathObj))
            graphLabel = torch.tensor(np.asarray([numericalFamilyValue]), dtype=torch.int64)
            
            nodes = np.asarray(nodes)
            nodes = torch.tensor(nodes, dtype=torch.float32)
            edgeIndices = torch.tensor(allEdges)
            edgeFeatures = torch.tensor(allEdgeFeatures, dtype=torch.float32)
            # Read data from `raw_path`.
            data = Data(
                x = nodes,
                edge_index = edgeIndices,
                edge_attr = edgeFeatures,
                y=graphLabel
            )

            # filters out data
            if self.pre_filter is not None and not self.pre_filter(data):
                continue

            if self.pre_transform is not None:
                data = self.pre_transform(data)

            rawDataPath = Path(self.raw_dir)

            self._addClassNameAttribute(data, rawDataPath, numericalFamilyValue)
            self._addNodeNamesAttribute(data, nodeNames)
            torch.save(data, osp.join(self.processed_dir, outputGraphFileName))

    def len(self):
        return len(self.processed_file_names)

    def get(self, idx):
        pattern = f"{self.processed_dir}/*_{idx}.pt"
        matchingFiles = glob.glob(pattern)
        if matchingFiles:
            return torch.load(osp.join(matchingFiles[0]))
        raise FileNotFoundError(f"The specified file data object not found: {idx = }")
    
    def _load_node_feature(self) -> torch.Tensor:
        """ 
        This will return a tensor / 2d array of the shape
        [Number of Nodes, Node Feature size]
        """
        apiCallWordVector = KeyedVectors.load(self.apiCallEmbeddingsFilePath)
        allNodeFeats = []
        nodeIndex = 0
        for apiCall, t in apiCallWordVector.key_to_index.items():
            allNodeFeats.append(apiCallWordVector[apiCall])
            self.apiToNodeIndex[apiCall] = nodeIndex
            self.nodeIndexToApi.append(apiCall)
            nodeIndex += 1
        allNodeFeats = np.asarray(allNodeFeats)
        save_dict_if_changed(self.apiToNodeIndex, "APICallToNodeFeatureIndex.json")
        return torch.tensor(allNodeFeats, dtype=torch.float32)
    
    # return just getting it to work for time limited....
    def _construct_graph(self, rawFilePath: str) -> tuple[list[list], list[int], list, list[str]]:
        # [Number of edge, Edge Feature size]
        if not self.weighted:
            return [] # not valid needs fixing!!!!!!
        
        edgeWeight: dict[tuple[str, str], int] = {}
        # each row is a node shape [num of node, num of node features]
        nodes = []
        seenAPICallsNewIndex: dict[str, int] = {}
        nodeNames: list[str] = []
        # for rawFilePath in self.raw_paths:
        with open(rawFilePath, "r") as apiLog:
            for line1, line2 in zip(apiLog, apiLog):
                if line1 is None or line2 is None or line1.isspace() or line2.isspace() or len(line1) == 0 or len(line2) == 0:
                    continue

                line1Norm = line1.lower().strip("\n")
                line2Norm = line2.lower().strip("\n")

                if line1Norm not in seenAPICallsNewIndex:
                    seenAPICallsNewIndex[line1Norm] = len(nodes)
                    nodes.append(self.nodeFeatures[self.apiToNodeIndex[line1Norm]])
                    nodeNames.append(line1Norm)
                if line2Norm not in seenAPICallsNewIndex:
                    seenAPICallsNewIndex[line2Norm] = len(nodes)
                    nodes.append(self.nodeFeatures[self.apiToNodeIndex[line2Norm]])
                    nodeNames.append(line2Norm)
                
                if (line1Norm, line2Norm) not in edgeWeight:
                    edgeWeight[(line1Norm, line2Norm)] = 1
                else:
                    edgeWeight[(line1Norm, line2Norm)] += 1
        


        


        allEdges: list[list] = [[],[]]
        allEdgeFeatures: list[int] = []
        for edgeTuple, weight in edgeWeight.items():
            # undirected graph thus, need to have the same wight per direction
            # and have source -> destination and destination -> source
            allEdgeFeatures += [weight, weight]
            allEdges[0] += [seenAPICallsNewIndex[edgeTuple[0]], seenAPICallsNewIndex[edgeTuple[1]]]
            allEdges[1] += [seenAPICallsNewIndex[edgeTuple[1]], seenAPICallsNewIndex[edgeTuple[0]]]


        return allEdges, allEdgeFeatures, nodes, nodeNames
    
    def _get_label(self, rawFilePath: Path):
        # parent dir names are the family the malware belongs to
        # thus is the graph label
        parentDirPath = rawFilePath.parent
        parentDirName = parentDirPath.stem
        return parentDirName
    
    def _make_file_name(self, rawFilePathWithClassDirAsName: Path, fileNameMetaInfo: str, index: int) -> str:
        fileName = rawFilePathWithClassDirAsName.stem
        parentDirPath = rawFilePathWithClassDirAsName.parent
        parentDirName = parentDirPath.stem
        processedFileName = f"{parentDirName}_{fileName}_{fileNameMetaInfo}_{index}.pt"
        return processedFileName
    
    # might no be needed
    def one_hot_encode(self, familyLabel: str):
        numericalFamilyValue = self.allClassLabels[familyLabel]
        numClasses = len(self.allClassLabels)
        # oneHotEncodedLabel = torch.nn.functional.one_hot(torch.tensor(numericalFamilyValue), numClasses)
        oneHotEncodedLabel = torch.nn.functional.one_hot(torch.tensor(int(numericalFamilyValue)).long(), numClasses)
        return oneHotEncodedLabel
    
    def _addClassNameAttribute(self, data: Data, rawDataPath: Path, integer_class_representation: int):
        familyLabels = generateFamilyLabels(rawDataPath)
        data.className = familyLabels[integer_class_representation]
        return data

    def _addNodeNamesAttribute(self, data: Data, nodeNames: list[str]):
        """
        :param nodeNames: shape [number of node in graph, nodeName(APIcall in this case)]
        """
        data.allNodeNames = nodeNames
        return data


class APICallTopologicalGraphDataset(APICallGraphDataset):
    def __init__(self, root: str, processSubDir: str, fileNameMetaInfoSuffix: str, apiCallEmbeddingsFilePath: str, allClassLabels: dict[str, int], transform=None, pre_transform=None, pre_filter=None):
        self.apiCallEmbeddingsFilePath: str = apiCallEmbeddingsFilePath
        self.apiToNodeIndex: dict[str, int] = {}
        self.nodeIndexToApi: list[str] = []
        self.nodeFeatures: torch.Tensor | None = None
        self.allClassLabels: dict[str, int] = allClassLabels
        self.weighted = False
        self.processSubDir = processSubDir
        self.fileNameMetaInfoSuffix = fileNameMetaInfoSuffix
        super().__init__(root, processSubDir, self.fileNameMetaInfoSuffix, apiCallEmbeddingsFilePath, self.weighted, allClassLabels, transform, pre_transform, pre_filter)

    @property
    def processed_dir(self) -> str:
        return osp.join(self.root, 'processed', self.processSubDir)
    
    @property
    def processed_file_names(self):
        rawFilePaths: list[str] = self.raw_file_names
        processedFileNames: list[str] = []
        for idx, filePath in enumerate(rawFilePaths):
            filePathObj = Path(filePath)
            procFileName = self._make_file_name(filePathObj, self.fileNameMetaInfoSuffix, idx)
            processedFileNames.append(procFileName)
        return processedFileNames

    def download(self):
        # Download to `self.raw_dir`.
        pass
    
    def process(self):
        self.nodeFeatures = self._load_node_feature()
        for idx, raw_path in enumerate(self.raw_file_names):
            filePathObj: Path = Path(raw_path)
            outputGraphFileName = self._make_file_name(filePathObj, self.fileNameMetaInfoSuffix, idx)
            # UW unweighted
            # outputGraphFileName = f"{outputGraphFileName}_top_UW"
            numericalFamilyValue: int = self.allClassLabels[self._get_label(filePathObj)]
            graphLabel = torch.tensor(np.asarray([numericalFamilyValue]), dtype=torch.int64)
            currentGraphNodeFeatures, currentGraphNodeNames, edgeIndices = self._constructGraph(raw_path)
            currentGraphNodeFeatures = np.asarray(currentGraphNodeFeatures)
            currentGraphNodeFeatures = torch.tensor(currentGraphNodeFeatures, dtype=torch.float32)

            edgeIndices = torch.tensor(edgeIndices)


            # Read data from `raw_path` as graph.
            data = Data(
                x = currentGraphNodeFeatures,
                edge_index = edgeIndices,
                y=graphLabel
            )

            # filters out data
            if self.pre_filter is not None and not self.pre_filter(data):
                continue

            if self.pre_transform is not None:
                data = self.pre_transform(data, graphLabel)            

            rawDataPath = Path(self.raw_dir)
            self._addClassNameAttribute(data, rawDataPath, numericalFamilyValue)
            self._addNodeNamesAttribute(data, currentGraphNodeNames)

            torch.save(data, osp.join(self.processed_dir, outputGraphFileName))
        
    def _constructGraph(self, rawFilePath: str):
        # each row is a node shape [num of node, num of node features]
        nodes = []
        nodeNames: list[str] = []
        # top list is source node, bottom list is destination node
        edges: list[list[int]] = [[], []]
        sourceNodeIndex = 0
        destinationNodeIndex = 1
        with open(rawFilePath, "r") as apiLog:
            for line1, line2 in zip(apiLog, apiLog):
                if line1 is None or line2 is None or line1.isspace() or line2.isspace() or len(line1) == 0 or len(line2) == 0:
                    if not (line1 is None) and line2.isspace():
                        lastLineNormNode = line1.lower().strip("\n")
                        # secondToLastNodeName = nodeNames[len(nodeNames) - 1]
                        # add last node
                        nodes.append(self.nodeFeatures[self.apiToNodeIndex[lastLineNormNode]])
                        nodeNames.append(lastLineNormNode)
                        # add secondToLastNode -> lastLineNormNode edge
                        edges[0].append(sourceNodeIndex-1)
                        edges[1].append(sourceNodeIndex)

                    continue
                line1NormSourceNode = line1.lower().strip("\n")
                line2NormDestinationNode = line2.lower().strip("\n")

                # add two NEW nodes to graph with node embedding based on word2vec
                # thus each node is unique in the graph but can have duplicate node embedding vectors
                nodes.append(self.nodeFeatures[self.apiToNodeIndex[line1NormSourceNode]])
                nodes.append(self.nodeFeatures[self.apiToNodeIndex[line2NormDestinationNode]])
                nodeNames.append(line1NormSourceNode)
                nodeNames.append(line2NormDestinationNode)

                # connects the last destination node from 
                # the previous iteration to this iterations's source node
                # thus making a sequential topological order
                if len(nodes) >= 2:
                    edges[0].append(sourceNodeIndex-1)
                    edges[1].append(sourceNodeIndex)

                # connect the two newly added nodes in the graph
                edges[0].append(sourceNodeIndex)
                edges[1].append(destinationNodeIndex)

                sourceNodeIndex += 2
                destinationNodeIndex += 2
                
        return nodes, nodeNames, edges