import os.path as osp
from os import walk
from pathlib import Path
import glob
import torch
from torch_geometric.data import Dataset, Data
from gensim.models import KeyedVectors
import numpy as np

class APICallGraphDataset(Dataset):
    def __init__(self, root: str, apiCallEmbeddingsFilePath: str, weighted: bool, allClassLabels: dict[str, int], transform=None, pre_transform=None, pre_filter=None):
        # super().__init__(root, transform, pre_transform, pre_filter)
        # self.areAttributesInitialized = False
        # self.apiCallEmbeddingsFilePath: str = apiCallEmbeddingsFilePath
        # self.apiToNodeIndex: dict[str, int] = {}
        # self.weighted = weighted
        # self.nodeFeatures: torch.Tensor | None = None
        # self.allClassLabels: dict[str, int] = allClassLabels
        self.areAttributesInitialized = False
        self.apiCallEmbeddingsFilePath: str = apiCallEmbeddingsFilePath
        self.apiToNodeIndex: dict[str, int] = {}
        self.weighted = weighted
        self.nodeFeatures: torch.Tensor | None = None
        self.allClassLabels: dict[str, int] = allClassLabels
        super().__init__(root, transform, pre_transform, pre_filter)
   
    @property
    def raw_file_names(self):
        # rootDir: str = super().root
        rootDir: str = self.root
        filePaths: list[str] = []
        for subdir, dirs, files in walk(osp.join(rootDir, "raw")):
            for file in files:
                filePath: str = osp.join(subdir, file)
                filePaths.append(filePath)
                # filePaths.append(file)
        return filePaths

    @property
    def processed_file_names(self):
        rawFilePaths: list[str] = self.raw_file_names
        processedFileNames: list[str] = []
        for idx, filePath in enumerate(rawFilePaths):
            filePathObj = Path(filePath)
            # fileName = filePathObj.stem
            # parentDirPath = filePathObj.parent
            # parentDirName = parentDirPath.stem
            # procFileName = f"{parentDirName}_{fileName}_{idx}.pt"
            procFileName = self._make_file_name(filePathObj, idx)
            processedFileNames.append(procFileName)
        return processedFileNames
    
    # @property
    # def processed_paths(self) -> list[str]:
    #     r"""The absolute filepaths that must be present in order to skip
    #     processing.
    #     """
    #     files = self.processed_file_names
    #     # Prevent a common source of error in which `file_names` are not
    #     # defined as a property.
    #     if isinstance(files, Callable):
    #         files = files()
    #     return [osp.join(self.processed_dir, f) for f in self.to_list(files)]

    def download(self):
        # Download to `self.raw_dir`.
        pass

    def process(self):
        self.nodeFeatures = self._get_node_feature()
        for idx, raw_path in enumerate(self.raw_file_names):
            filePathObj: Path = Path(raw_path)
            outputGraphFileName = self._make_file_name(filePathObj, idx)
            # processedFilePath = f"{outputGraphFileName}"
            edgesWeightsDict: dict[tuple[str, str], int] = self._get_edge_weight_features(raw_path)
            
            numericalFamilyValue = self.allClassLabels[self._get_label(filePathObj)]
            # graphLabel = self.one_hot_encode(self._get_label(filePathObj))
            graphLabel = torch.tensor(np.asarray([numericalFamilyValue]), dtype=torch.int64)

            allEdgeFeatures: list[int] = []
            allEdges: list[list] = [[],[]]
            for edgeTuple, weight in edgesWeightsDict.items():
                # undirected graph thus, need to have the same wight per direction
                # and have source -> destination and destination -> source
                allEdgeFeatures += [weight, weight]
                allEdges[0] += [self.apiToNodeIndex[edgeTuple[0]], self.apiToNodeIndex[edgeTuple[1]]]
                allEdges[1] += [self.apiToNodeIndex[edgeTuple[1]], self.apiToNodeIndex[edgeTuple[0]]]
            
            edgeIndices = torch.tensor(allEdges)
            edgeFeatures = torch.tensor(allEdgeFeatures, dtype=torch.float32)
            # Read data from `raw_path`.
            data = Data(
                x = self.nodeFeatures,
                edge_index = edgeIndices,
                edge_attr = edgeFeatures,
                y=graphLabel
            )

            # filters out data
            if self.pre_filter is not None and not self.pre_filter(data):
                continue

            if self.pre_transform is not None:
                data = self.pre_transform(data)

            torch.save(data, osp.join(self.processed_dir, outputGraphFileName))

    def len(self):
        return len(self.processed_file_names)

    def get(self, idx):
        pattern = f"{self.processed_dir}/*_{idx}.pt"
        matchingFiles = glob.glob(pattern)
        if matchingFiles:
            return torch.load(osp.join(matchingFiles[0]))
        raise FileNotFoundError(f"The specified file data object not found: {idx = }")
    
    def _get_node_feature(self) -> torch.Tensor:
        """ 
        This will return a tensor / 2d array of the shape
        [Number of Nodes, Node Feature size]
        """
        apiCallWordVector = KeyedVectors.load(self.apiCallEmbeddingsFilePath)
        allNodeFeats = []
        nodeIndex = 0
        for apiCall, t in apiCallWordVector.key_to_index.items():
            allNodeFeats.append(apiCallWordVector[apiCall])
            self.apiToNodeIndex[apiCall] = nodeIndex
            nodeIndex += 1
        allNodeFeats = np.asarray(allNodeFeats)
        return torch.tensor(allNodeFeats, dtype=torch.float32)
    
    def _get_edge_weight_features(self, rawFilePath: str) -> dict[tuple[str, str], int]:
        # [Number of edge, Edge Feature size]
        if not self.weighted:
            return []
        edgeWeight: dict[tuple[str, str], int] = {}

        # for rawFilePath in self.raw_paths:
        with open(rawFilePath, "r") as apiLog:
            for line1, line2 in zip(apiLog, apiLog):
                if line1 is None or line2 is None:
                    continue
                line1Norm = line1.lower().strip("\n")
                line2Norm = line1.lower().strip("\n")
                
                if (line1Norm, line2Norm) not in edgeWeight:
                    edgeWeight[(line1Norm, line2Norm)] = 1
                else:
                    edgeWeight[(line1Norm, line2Norm)] += 1
        return edgeWeight
    
    def _get_label(self, rawFilePath: Path):
        # parent dir names are the family the malware belongs to
        # thus is the graph label
        parentDirPath = rawFilePath.parent
        parentDirName = parentDirPath.stem
        return parentDirName
    
    def _make_file_name(self, rawFilePath: Path, index: int) -> str:
        fileName = rawFilePath.stem
        parentDirPath = rawFilePath.parent
        parentDirName = parentDirPath.stem
        processedFileName = f"{parentDirName}_{fileName}_{index}.pt"
        return processedFileName
    
    # might no be needed
    def one_hot_encode(self, familyLabel: str):
        numericalFamilyValue = self.allClassLabels[familyLabel]
        numClasses = len(self.allClassLabels)
        # oneHotEncodedLabel = torch.nn.functional.one_hot(torch.tensor(numericalFamilyValue), numClasses)
        oneHotEncodedLabel = torch.nn.functional.one_hot(torch.tensor(int(numericalFamilyValue)).long(), numClasses)
        return oneHotEncodedLabel
